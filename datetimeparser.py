import datetime


class DateTimeParser:
    """
    Parse strings to datetime.time-, -date- or -datetime-objects.

    This class defines four class-attributes::

        TIME_FORMATS = [
            '%H:%M',
            '%H:%M:%S',
            '%H:%M:%S.%f',
            ]
        DATE_FORMATS = [
            '%Y.%m.%d',
            '%y.%m.%d',
            ]
        DATETIME_FORMATS = list()
        DATETIME_DELIMITER = [' ', ',', ';']
    
    Feel free to overwrite the defaults for these attributes.
    """
    TIME_FORMATS = [
        '%H:%M',
        '%H:%M:%S',
        '%H:%M:%S.%f',
        ]
    DATE_FORMATS = [
        '%Y.%m.%d',
        '%y.%m.%d',
        '%Y-%m-%d',
        '%y-%m-%d',
        ]
    DATETIME_FORMATS = list()
    DATETIME_DELIMITER = [' ', ',', ';']

    @classmethod
    def parsetime(cls, value, formats=list()):
        """
        Parse a string to a datetime.time-object.

        Args:
            value (str):    string to parse
            formats (list): list of timecode-formats

        Parsing value is tried out with every format in formats. If formats not
        given DateTimeParser.TIME_FORMATS is used instead.
        The first format that fits is used.

        Return a datetime.time-object.
        Raises ValueError if value couldn't be parsed as time.
        """
        if not formats: formats = cls.TIME_FORMATS
        for f in formats:
            try: return datetime.datetime.strptime(value, f).time()
            except ValueError: continue
        raise

    @classmethod
    def parsedate(cls, value, formats=list()):
        """
        Parse a string to a datetime.date-object.

        Args:
            value (str):    string to parse
            formats (list): list of timecode-formats

        Parsing value is tried out with every format in formats. If formats not
        given DateTimeParser.DATE_FORMATS is used instead.
        The first format that fits is used.

        Return a datetime.date-object.
        Raises ValueError if value couldn't be parsed as date.
        """
        if not formats: formats = cls.DATE_FORMATS
        for f in formats:
            try: return datetime.datetime.strptime(value, f).date()
            except ValueError: continue
        raise

    @classmethod
    def parsedatetime(cls, value, formats=list()):
        """
        Parse a string to a datetime.datetime-object.

        Args:
            value (str):    string to parse
            formats (list): list of timecode-formats

        Parsing value is tried out with every format in formats. If formats not
        given DateTimeParser.DATETIME_FORMATS is used instead. If this is an
        list (which it is by default), a format-list is generated by combining
        every DATE_FORMAT with every TIME_FORMAT using every delimiter defined
        in DateTimeParser.DATETIME_DELIMITER.
        The first format that fits is used.

        Return a datetime.datetime-object.
        Raises ValueError if value couldn't be parsed as datetime.
        """
        if not formats: formats = cls.DATETIME_FORMATS
        if not formats:
            df = cls.DATE_FORMATS
            tf = cls.TIME_FORMATS
            for delimiter in cls.DATETIME_DELIMITER:
                formats += [delimiter.join((d, t)) for d in df for t in tf]
        for f in formats:
            try: return datetime.datetime.strptime(value, f)
            except ValueError: continue
        raise



